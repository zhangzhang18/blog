---
title: 准备面试
copyright: true
abbrlink: fc812cf3
date: 2017-03-01 11:14:08
tags:
  - JAVA
  - 面试
top:
---
###### spring事务传播特性
 
    事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。   
    propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。    
    propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。    
    propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。     
    propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。    
    propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。     
    propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。     
    propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 
###### 了解Spring使用到的设计模式吗？     
###### 说说对MQ理解

    https://github.com/doocs/advanced-java
    作用：解耦、消峰、异步、广播
    如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。
    如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。
    这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。
    
    保证消息消费幂等性（重复消费问题）
       1.写库时，先跟进主键确认是否已存在 2.redis的set 
    处理消息丢失问题
     生产者
       1.使用事物，如果失败就回滚，重试发送消息，成功便提交事务
       2.开启confirm模式，持久化queue元数据，将消息持久化到磁盘，消息被持久化到磁盘，再通知生产者，
###### 了解MQ 底层吗

###### 为什么要用缓存
       
           用缓存，主要有两个用途：高性能、高并发。
           
           高性能：就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直接将查询出来的结果放在缓存中，后面直接读缓存就好。
           高并发：缓存是走内存的，内存天然就支撑高并发。
###### Redis

    缓存雪崩：缓存挂了，所有请求都打到数据库
        缓存雪崩的事前事中事后的解决方案如下。
         事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。
         事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。
         事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。
    缓存穿透：缓存中查不到，每次去数据库里查，也查不到。就会直接把数据库给打死
        解决方式：从数据库中只要没查到，就写一个空值到缓存里去
                  然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。
    缓存击穿：就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。
         解决方式：可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。
###### Redis 过期策略

    1.定期删除+惰性删除。
    所谓定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。
    惰性删除，获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。
    2.走内存淘汰机制---在内存不足容纳新的数据的的时候
        a).noeviction :    新写入数据报错
        b).allkeys-lru：   在所有键中，删除最近最少使用的键
        c).allkeys-random：在所有键中，随机删除某个键
        d).volatile-lru：  在设置过期时间的键中，删除最近最少使用的键
        e).volatile-random:在设置过期时间的键中，随机删除某个键
        f).volatile-ttl：  在设置过期时间的键中，删除最早过期的键
        
###### Redis 主从架构 哨兵集群实现高可用
    
    一:主从架构
       一主多从： 主负责写，并且将数据复制到从节点，从节点负责读
###### mysql 读写分离
    主库将变更写到binlog中，当从库连接到主库后，
    从库有一个IO线程，将主库的binlog日志copy到自己本地，执行binlog中的日志内容，写入relay log，就是在自己本地再执行一遍sql。
    
    从库同步主库的数据过程是串行化的，也就是主库并行的操作，在从库会串行执行。
    高并发场景下，从库数据就会比主库慢，有延时
    
    如果主库突然宕机，数据还没同步到从库时，MySql有两个机制
    半同步复制和并行复制
    1:主库写入binlog后，强制立即将数据同步到从库，从库写入relay log后，从库会返回ask给主库，主库接收至少一个从库的ask才会认为写操作完成。
    2：从库开启多个线程，并行取relay log中不同库的数据，并行重放不同库的日志。
###### 高并发系统设计
        1.系统拆分 2.缓存 3.MQ 4.分库分表 5.读写分离 6.ElasticSearch
###### 说说一次 rpc 请求的流程？
    
    第一步：provider 向注册中心去注册
    第二步：consumer 从注册中心订阅服务，注册中心会通知 consumer 注册好的服务
    第三步：consumer 调用 provider
    第四步：consumer 和 provider 都异步通知监控中心
    
    Dubbo 传输协议：Dubbo缺省协议采用单一长连接和NIO异步通讯，
注册中心挂了可以继续通信吗？

     可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。    
###### 说说对zk的理解？
### 注解的理解