---
title: JVM内存分配
date: '2017/7/13 20:46:25'
copyright: true
categories:
  - NoteBook
tags:
  - JAVA
  - JVM
abbrlink: f12cd388

---
![jvm](jvm.jpg)

# 线程私有的：

>  程序计数器  虚拟机栈  本地方法栈

线程共享的：
>   堆  方法区  直接内存
<!-- more -->
## 1.程序计数器（PCR）【线程私有】
可以看做当前线程所执行的**字节码的行号指示器**。(通过计数器得值选取下一条需要执行得字节码指令)  
为了线程切换后能够恢复到正确执行位置，每条线程都需要独立的程序计数器，独立存储。  
## 2.栈（JVM stack）【线程私有】
生命周期与线程相同。  
描述的是**Java方法**执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储**局部变量表，操作数栈，动态链接方法出口**。  
局部变量表存放了编译期可知得各种基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用和returnAddress类型。  
每个方法执行到完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  
- StackOverflowError异常：如果线程请求得栈深度大于虚拟机允许得深度，抛出该异常。  
- OutOfMemoryError异常：如果拓展时无法申请到足够内存，抛出该异常。  
## 3.本地方法栈（Native Method Stack）【线程私有】
与JVM栈相似，本地方法栈是用的是虚拟机的native方法  
与JVM栈一样会抛出StackOverflowError，OutOfMemoryError异常  
## 4.堆（heap)【线程共享】
是Java虚拟机管理内存中最大的一块。
是被所有线程共享的一块内存区域，此内存区域唯一目的是存放对象实例，几乎所有的对象及数组都要在这里分配内存。  
是垃圾回收器管理的主要区域，因此很多时候也被称作“GC堆”。  
现在收集器采用分代收集算法，所以Java堆还可以细分为：新生代，老年代；在细分（Eden空间，From Survivor空间，To Survivor空间），从内存分配角度来看，线程共享的Java堆可能划分出多个线程私有的分配缓存区（Thread Local Allocation Buffer, TLAB）。    
Java堆可以位于物理上不连续的空间，但是逻辑上要连续。  
- OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。
## 5.方法区（Method）【线程共享】
域Java堆一样。是各个线程共享的内存区域，用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
## 6.运行时常量池（Runtime Constant Pool）
是方法区的一部分。
Class文件不仅有类的版本，字段，方法，接口描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。
## 7.直接内存（Direct Memory）
不是虚拟机运行数据区的一部分。
NIO（New Input/Output）类，引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存。通过一个Java堆DirectByteBuffer对象作为这块内存的引用进行操作。
显著提高性能，因为避免了Java堆和Native堆来回复制数据。
## 8、永久代、方法区和元空间之间的关系
   《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。  
   在1.7之前在(JDK1.2 ~ JDK6)的实现中，HotSpot 使用永久代实现方法区。  
   在JDK1.8中，元空间取代了永久代，来实现方法区。

--------------------------------------------------------------------------------
![java内存梳理图](java内存.png)
