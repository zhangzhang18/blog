---
title: JVM内存分配
date: '2017/7/13 20:46:25'
copyright: true
categories:
  - NoteBook
tags:
  - JAVA
  - JVM
abbrlink: f12cd388

---
![jvm](jvm.jpg)

# 线程私有的：

>  程序计数器  虚拟机栈  本地方法栈
    
线程共享的：
>   堆  方法区  直接内存
<!-- more -->
## 1.程序计数器（PCR）
可以看做当前线程所执行的字节码的行号指示器。
为了线程切换后能够恢复到正确执行位置，每条线程都需要独立的程序计数器。
## 2.栈（JVM stack）
线程私有，生命周期与线程相同。
描述的事Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接方法出口。
每个方法执行到完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
## 3.本地方法栈（Native Method Stack）
与JVM栈相似，本地方法栈是用的是虚拟机的native方法
## 4.堆（heap)
是Java虚拟机管理内存中最大的一块。
是被所有线程共享的一块内存区域，次内存区域唯一目的是存放对象实例，几乎所有的对象及数组都要在这里分配内存。
是垃圾回收器管理的主要区域，因此很多时候也被称作“GC堆”。
现在收集器采用分代收集算法，所以Java堆还可以细分为：新生代，老年代；
## 5.方法区（Method）
域Java堆一样。是各个线程共享的内存区域，
用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
## 6.运行时常量池（Runtime Constant Pool）
是方法区的一部分。
Class文件不仅有类的版本，字段，方法，接口描述信息外，还有一项信息是常量池，
用于存放编译期生成的各种字面量和符号引用。
## 7.直接内存（Direct Memory）
不是虚拟机运行数据区的一部分。
NIO（New Input/Output）类，引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存。通过一个Java堆DirectByteBuffer对象作为这块内存的引用进行操作。
显著提高性能，因为避免了Java堆和Native堆来回复制数据。

--------------------------------------------------------------------------------

栈区：每次方法的执行都会有一次栈帧的生成，并且其中有局部变量表。
堆区：每次new出来的对象都保存在这儿。
本地方法栈：通过C/C++调用系统接口的一些方法。
方法区：类的信息 静态变量都在这儿，还有程序计数器