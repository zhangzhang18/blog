---
title: 面试常用手写代码
date: '2017/10/12 21:07:31'
copyright: true
categories:
  - NoteBook
tags:
  - JAVA
  - 面试
abbrlink: e06601f2
---

# 排序
## 快速排序

```
int a[10],n;
void quickSort(int left,int right){
  int i,j,t,temp;
  if(left >right){
    return;
  }
  temp=a[left];
  i=left;
  j=right;
  while(i!=j){
    while(a[j]>=temp&&i<j){
        j--;
    }
    while(a[i]>=temp&&i<j){
        i++;
    }
    if(i<j){
        t=a[i];
        a[i]=a[j];
        a[j]=t;
    }
  }
  a[left]=a[i];
  a[i]=temp;
  quicpSort(left,i-1);
  quickSort(i+1,right);
}
```
<!-- more -->
![快速排序步骤](ps.png)
![快速排序理解](ps2.png)
## 归并排序

```
 void mergeSort(int[] arr, int start, int end) {
        if (start < end) {
            //折半成两个小集合，分别进行递归
            int mid = (start + end) / 2;
            mergeSort(arr, start, mid);
            mergeSort(arr, mid + 1, end);
            //把有序小集合，归并成大集合
            merge(arr, start, mid, end);
        }
    }

    void merge(int[] arr, int start, int mid, int end) {
        //开辟额外大集合
        int[] temp = new int[end - start + 1];
        int p1 = start, p2 = mid + 1, p = 0;
        //比较两个小集合放入大集合
        while (p1 < mid && p2 < end) {
            if (arr[p1] <= arr[p2]) {
                temp[p++] = arr[p1++];
            } else {
                temp[p++] = arr[p2++];
            }
        }
        //左侧有剩余
        while (p1 < mid) {
            temp[p++] = arr[p1++];
        }
        //右侧有剩余
        while (p2 < end) {
            temp[p++] = arr[p2++];
        }
        //复制回原数组
        for (int i = 0; i < temp.length; i++) {
            arr[i + start] = temp[i];
        }
    }
```
![归并图解](ms.jpg)

![排序对比](allSort.png)
# 单例
## 双重校验锁
volatile 的一个语义禁止指令重排优化。在读取变量的时候直接从内存读取，保证所有线程看到的变量值都是相同的，
synchronized关键字锁住类
进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。

```java
public class Singleton {
  private volatile static Singleton instance = null;
  private Singleton(){}
  public static Singleton getInstance(){
  //检查实例，如果不存在，就进入同步代码块
      if (instance==null){//  双重检测机制  
          synchronized(Singleton.class){//1  同步锁 类对象加锁
              if(instance == null){//2  双重检测机制
                  instance = new Singleton();//3  
              }
          }
      }
      return instance;
  }
}
```
![single](single.jpg)
## 静态内部类
```java
public class Singleton {
    private static class LazyHolder{
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton(){}
    public static Singleton getInstance(){
      return LazyHolder.INSTANCE;
    }
}
```
## enum
```java
// JVM会组织反射获取枚举类的私有构造方法
public enum Singleton {
    INSTANCE;
    public void whateverMethod() {

    }
}
```
![compare](compare.jpg)

# 二叉树
## 非递归遍历二叉树

```java
 void preOrder(Node head) {
        if(head != null) {
            Stack<Node> stack = new Stack<>();
            stack.push(head);
            while(!stack.isEmpty()) {
                head = stack.pop();
                System.out.print(head.val + " ");
                if (head.right != null)
                    stack.push(head.right);
                if (head.left != null)
                    stack.push(head.left);
            }
        }
    }

```

## 二叉树的深度

```java
   int findDeep(BiTree root)  
  {  
      int deep = 0;  
      if(root != null)  
      {  
          int lchilddeep = findDeep(root.left);  
          int rchilddeep = findDeep(root.right);  
          deep = lchilddeep > rchilddeep ? lchilddeep + 1 : rchilddeep + 1;  
      }  
      return deep;  
  }  
``` 

# 链表
## 单链表反转

```java
     Node reverse(Node head) {
        if (head == null) {
            return null;
        }
        Node prev = null;
        Node now = head;
        while (now != null) {
            Node next = now.next;
            now.next = prev;
            prev = now;
            now = next;
        }
        return prev;
    }
```
### 删除重复值

```java
      Node deleteRepeat(Node head) {
        if (null == head || null == head.next) {
            return head;
        }
        Node pre = head;
        Node cur = head.next;

        while (cur != null) {
            if (cur.val == pre.val) {
                pre.next = cur.next;
            } else {
                pre = cur;
            }
            if (cur.next == null) {
                return head;
            }
            cur = cur.next;
        }
        return cur;
    }
```
## 判断链表是否有环

```java
    Node meetingNode(Node head) {
        if (head == null) {
            return null;
        }
        Node slow = head.next;
        if (slow == null) {
            return null;
        }
        Node fast = slow.next;
        while (slow != null && fast != null) {
            if (slow == fast) {
                return fast;
            }
            slow = slow.next;
            fast = fast.next;
            if (fast != null) {
                fast = fast.next;
            }
        }
        return null;
    }
```
## 链表中环入口节点
```java
    Node nodeOfLoop(Node head) {
        if (head == null) {
            return null;
        }
        //得到相遇节点
        Node meetingNode = meetingNode(head);
        if (meetingNode == null) {
            return null;
        }
        //得到环节点数
        int nodeInLoopNum = 1;
        Node p1 = meetingNode;
        while (p1.next != meetingNode) {
            p1 = p1.next;
            ++nodeInLoopNum;
        }
        p1 = head;
        Node p2 = head;
        //p1先移动环节点数nodeInLoopNum步
        for (int i = 0; i < nodeInLoopNum; i++) {
            p1 = p1.next;
        }
        //然后p1,p2以相同速度移动
        while (p1 != p2) {
            p1 = p1.next;
            p2 = p2.next;
        }
        return p1;
    }
```

## 判断两个链表是否相交

```java
    boolean isIntersert(Node h1, Node h2) {
        if (h1 == null || h2 == null) {
            return false;
        }
        Node tail = h1;
        Node tail2 = h2;
        while (tail.next != null) {
            tail = tail.next;
        }
        while (tail2.next != null) {
            tail2 = tail2.next;
        }
        return tail == tail2;
    }
```

# 数组

### 合并两个有序数据，结果任然有序

```java
     int[] merge(int[] a, int[] b) {
        int[] result;
        result = new int[a.length + b.length];
        int i = 0, j = 0, k = 0;
        while (i < a.length && j < b.length) {
            if (a[i] < b[j]) {
                result[k++] = a[i++];
            } else {
                result[k++] = b[j++];
            }
        }
        while (i < a.length) {
            result[k++] = a[i++];
        }
        while (j < b.length) {
            result[k++] = b[j++];
        }
        return result;
    }
```

### 二分查找

```java
   int binarySearch(int[] arr, int key) {
        int low = 0;
        int high = arr.length - 1;

        while (low <= high) {
            int mid = (low + high) / 2;
            if (key == arr[mid]) {
                return mid;
            } else if (key > arr[mid]) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return 0;
    }
```


