---
title: 面试常用手写代码
date: '2017/10/12 21:07:31'
copyright: true
categories:
  - NoteBook
tags:
  - JAVA
  - 面试
abbrlink: e06601f2
---


## 快速排序

```
int a[10],n;
void quickSort(int left,int right){
  int i,j,t,temp;
  if(left >right){
    return;
  }
  temp=a[left];
  i=left;
  j=right;
  while(i!=j){
    while(a[j]>=temp&&i<j){
        j--;
    }
    while(a[i]>=temp&&i<j){
        i++;
    }
    if(i<j){
        t=a[i];
        a[i]=a[j];
        a[j]=t;
    }
  }
  a[left]=a[i];
  a[i]=temp;
  quicpSort(left,i-1);
  quickSort(i+1,right);
}
```
<!-- more -->
## 单例模式
volatile 的一个语义禁止指令重排优化。在读取变量的时候直接从内存读取，保证所有线程看到的变量值都是相同的，
synchronized关键字锁住类
进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。

```java
public class Singleton {
  private volatile static Singleton instance=null;
  private Singleton(){}
  public static Singleton getInstance(){
  //检查实例，如果不存在，就进入同步代码块
      if (instance==null){//  双重检测机制  
          synchronized(Singleton.class){//1  同步锁 类对象加锁
              if(instance==null){//2  双重检测机制
                  instance=new Singleton();//3  
              }
          }
      }
      return instance;
  }
}
```
![single](single.jpg)
```java
//enum JVM会组织反射获取枚举类的私有构造方法
public enum Singleton {
    INSTANCE;
    public void whateverMethod() {

    }
}
```
![compare](compare.jpg)


## 非递归遍历二叉树
```
public void preOrder(Node head) {
        if(head != null) {
            Stack<Node> stack = new Stack<>();
            stack.push(head);
            while(!stack.isEmpty()) {
                head = stack.pop();
                System.out.print(head.val + " ");
                if (head.right != null)
                    stack.push(head.right);
                if (head.left != null)
                    stack.push(head.left);
            }
        }
    }

```
## 二叉树的深度
```
  public int findDeep(BiTree root)  
  {  
      int deep = 0;  
      if(root != null)  
      {  
          int lchilddeep = findDeep(root.left);  
          int rchilddeep = findDeep(root.right);  
          deep = lchilddeep > rchilddeep ? lchilddeep + 1 : rchilddeep + 1;  
      }  
      return deep;  
  }  
``` 

## 判断链表是否有环

```
typedef struct node{  
    char data ;  
    node * next ;  
}Node;  
bool exitLoop(Node *head)  
{  
    Node *fast, *slow ;  
    slow = fast = head ;  
  
    while (slow != NULL && fast -> next != NULL)  
    {  
        slow = slow -> next ;  
        fast = fast -> next -> next ;  
        if (slow == fast)  
            return true ;  
    }  
    return false ;  
}  
```
## 单链表反转

```
public Node reverse(Node node) {
    Node prev = null;
    Node now = node;
    while (now != null) {
      Node next = now.next;
      now.next = prev;
      prev = now;
      now = next;
    }

    return prev;
  }
```
###合并两个有序数据，结果任然有序
```
    public static int[] merge(int[] a, int[] b) {
        int[] result;
        result = new int[a.length + b.length];
        int i = 0, j = 0, k = 0;
        while (i < a.length && j < b.length) {
            if (a[i] < b[j]) {
                result[k++] = a[i++];
            } else {
                result[k++] = b[j++];
            }
        }
        while (i < a.length) {
            result[k++] = a[i++];
        }
        while (j < b.length) {
            result[k++] = b[j++];
        }
        return result;
    }
```

###删除重复值
```
    public static Node deleteRepeat(Node head) {
        if (null == head || null == head.next) {
            return head;
        }
        Node pre = head;
        Node cur = head.next;

        while (cur != null) {
            if (cur.val == pre.val) {
                pre.next = cur.next;
            } else {
                pre = cur;
            }
            if (cur.next==null) {
                return head;
            }
            cur = cur.next;
        }
        return cur;
    }
```
###二分查找

```
function binarySearch(arr, key) {
    var low = 0;
    var high = arr.length - 1;

    while (low <= high) {
        var mid = parseInt((low + high) / 2);
        if (key == arr[mid]) {
            return mid;
        } else if (key > arr[mid]) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

}
```


##判断两个链表是否相交

```
private boolean isIntersert(Node h1,Node h2){
    if(h1==null||h2==null)
        return false;
    Node tail =h1;    
    Node tail2 =h2;
    while(tail.next!=null)
        tail=tail.next;
    while(tail2.next!=null)
        tail2=tail2.next;
    return tail==tail2;
}
```
