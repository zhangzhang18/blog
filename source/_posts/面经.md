---
title: 面经
date: '2018/10/12 21:07:31'
copyright: true
categories:
  - NoteBook
tags:
  - JAVA
  - 面试
abbrlink: e16601f2
---

 

    
2.多线程的应用，理解
    
    多个线程同事运行，减少线程上下文切换的时间
    利用多线程可以提高系统整体并发能力及性能

    想要同时处理多件事：单线程处理不了的，必须使用多线程。（类似于分身术）
    多个线程分解大任务：用单线程可以做，但是使用多线程可以更快。（类似于左右开弓）
      
    多线程的常见应用场景：
    1、后台任务，例如：定时向大量（100w以上）的用户发送邮件；
    2、异步处理，例如：发微博、记录日志等；
    3、分布式计算
  
        Java的内存模式 是从主存读取变量，线程吧变量保存在本地内存（寄存器）中，不是直接从主存进行读写，一个线程修改主存的变量值，另一起还在使用寄存器中拷贝的值，造成数据不一致
    
    volatile变量–多线程间可见 （每次都从主存进行读取） 
    synchronized-一时刻只能有一个线程能获取到锁
    
    原子性：Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。
    同步异步：
    举例同步，你喊我吃饭，如果听见了，就一起去吃饭，如果没听见，你就不停喊，知道我听见才一起去吃饭，
    异步，你喊我吃饭，然后自己去吃饭，我听到消息可能立刻走也可能等下班才去吃饭。
    
3.线程之间的通信：
    
4.线程池
 
    降低资源消耗：事先创建若干个线程放在容器中，当使用的时候不需要自行创建，使用完不是去销毁而是归还到容器，减少了线程创建和销毁的时间
    提高响应速度：不需要等待线程创建
    提高线程的可管理性：无限制的创建线程，不仅消耗资源还降低系统稳定性，线程池可以进行统一分配，监控

    
5.为什么要用缓存？

    用缓存，主要有两个用途：高性能、高并发。
    redis数据结构 string,hash,list,set,sorted set、典型应用场景订单列表，消息，帖子评论列表等
    
    
6.对JVM的理解，内存溢出，内存泄露
    
    线程私有的：程序计数器  虚拟机栈  本地方法栈
    线程共享的：堆  方法区  直接内存
    堆主要用来存放对象，数组，栈主要是用来执行程序的，每个方法执行到完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
    方法区存储类信息，常量，静态变量 与堆一样线程共享
    常量池 类的版本，字段，方法，接口等描述信息 （字面量，符号引用）

    垃圾回收算法
    
    引用计数法
      给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。
     不能解决项目引用的问题。
    可达性分析法
     利用JVM对象引用图，从根节点遍历对象应用图，同时标记遍历到的对象。遍历结束后未被标记的对象就是不在使用的对象了
     可作为GC Roots的对象包括下面几种:
        虚拟机栈(栈帧中的本地变量表)中引用的对象。
        方法区中类静态属性引用的对象。
        方法区中常量引用的对象。
        本地方法栈中JNI(即一般说的Native方法)引用的对象。
    1.标记-清除算法
     算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
     它是最基础的收集算法，效率也很高，但是会带来两个明显的问题： 效率问题 空间问题（标记清除后会产生大量不连续的碎片）
    2.复制算法
     它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。
    3.标记-整理算法
     根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
    4.分代收集算法
     根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
     
     内存泄露
    一：在堆中申请的空间没有被释放，二：对象已经不在使用还在内存中保留
    原因：1.静态集合类 2.各种连接不显示的close 3.监听器没有删除 4.变量不合理的作用域 
    内存溢出
    指程序在申请内存时，没有足够的内存供申请者使用  
    原因：代码中存在死循环或循环产生过多重复的对象实体； 
          内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 
7.说说一次 rpc 请求的流程？
    
    第一步：provider 向注册中心去注册
    第二步：consumer 从注册中心订阅服务，注册中心会通知 consumer 注册好的服务
    第三步：consumer 调用 provider
    第四步：consumer 和 provider 都异步通知监控中心
    
    Dubbo 传输协议：Dubbo缺省协议采用单一长连接和NIO异步通讯，
注册中心挂了可以继续通信吗？

     可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。

----
8.索引
    
    索引就是个目录，字典的目录，有了目录就能更快的定位
    
    为了方便我们查找，提高查询的效率。
    
    缺点：索引需要维护成本，索引文件是单独存在的，数据的增删改 会产生会索引的额外操作，可能会影响增删改的速度
    
    原理：没有索引就是遍历整张表去查找
          把无序的数据变成有序的查询，把随机变成顺序
              1、把创建了索引的列的内容进行排序
              2、对排序结果生成倒排表
              3、在倒排表内容上拼上数据地址链
              4、在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据
          使用树形索引，还有哈希索引它适合单条查询
9.表单的重复提交
    
    在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。
10.悲观锁乐观锁

    悲观锁
      对数据加锁持有一种悲观的态度。因此，在整个数据处理过程中，将数据处于锁定状态。
      （共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）synchronized关键字的实现也是悲观锁
    乐观锁
      认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测 
      java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的
    悲观锁具有很强的独占性,也是最安全的.而乐观锁很开放,效率高

2.过滤器拦截器应用，区别

    filter->servlet->intercept->controller
    过滤器：Filter是实现了javax.servlet.Filter接口的服务器端程序
    过滤器用途：设置字符集，控制权限，过滤掉非法url，
    拦截器： SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor 来实现的
    拦截器用途：权限检查，如登录检查
    
     创建一个Filter只需两个步骤
        创建Filter处理类
        web.xml文件中配置Filter
     当web应用重新启动或销毁时，Filter也被销毁 
     void init(FilterConfig config):用于完成Filter的初始化。
     void destory():用于Filter销毁前，完成某些资源的回收。
     void doFilter(ServletRequest request,ServletResponse response,FilterChain chain):实现过滤功能
     
    拦截器实现
     preHandle (HttpServletRequest request, HttpServletResponse response, Object handle) 方法，该方法将在请求处理之前进行调用。当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；
     postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView) 方法，就是在当前请求进行处理之后，也就是Controller 方法调用之后执行
     afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex) 方法，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。
    
    
     过滤器和拦截器的区别：
     
     　　①拦截器是基于java的反射机制的，而过滤器是基于函数回调。
     　　②拦截器不依赖与servlet容器，过滤器依赖与servlet容器。
     　　③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。
     　　④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。
     　　⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。
     
     　　⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。

     原文：https://blog.csdn.net/chenleixing/article/details/44573495 
   
    
1.注解的理解
