---
title: Mysql技术内幕-第六章-锁
copyright: true
abbrlink: b46adbe2
date: 2020-04-07 17:01:07
categories:
  - NoteBook
tags: 
  - Mysql
  - Mysql技术内幕
  - 读书笔记
top:
---

# 1、什么是锁

----

> 锁机制用于管理对共享资源的并发访问，使用锁是为了支持对共享资源进行并发访问，提供数据完整性和一致性。

考点：InnoDB 最小的锁粒度是**行锁**，MyISAM 最小的锁粒度是**表锁**。

​	一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

## 2、lock和latch

> **latch**一般称为闩锁(轻量级的锁)，因为其要求锁定的时间必须非常短。若持续的时间长,则应用的性能会非常差。在 InnoDB存储引擎中，latch又可以分为 **mutex(互斥量)**和 **relock(读写锁)**。其目的是用来保证并发线程操作**临界资源的正确性**，并且通常没有死锁检测的机制。
> **lock**的对象是事务，用来锁定的是**数据库中的对象**,如表、页、行。并且一般lock的对象仅在事务 commit或 rollback后进行释放(不同事务隔离级别释放的时间可能不同)。此外,lock,正如在大多数数据库中一样,**是有死锁机制的**。

## 3、InnoDb存储引擎中的锁

### 3.1 锁的类型

两种行级锁：

- 共享锁S：允许事务读一行数据
- 排他锁X：允许事务删除或更新一行数据

X锁与任何锁都不兼容，S锁只能与S锁兼容。

**意向锁**：允许事务在行级上的锁和表级上的锁同时存在。

- 意向共享锁IS：事务想获得一张表中某几行的共享锁
- 意向排它锁IX：事务想获得一张表中某几行的排它锁

由于InnoDb是行级锁，意向锁不会阻塞除全表扫以外的任何请求

**意向锁不会与行级的共享 / 排他锁互斥**

|                      | 意向共享锁（IS） | 意向排他锁（IX） | S      | X      |
| -------------------- | ---------------- | ---------------- | ------ | ------ |
| **意向共享锁（IS）** | 兼容             | 兼容             | 兼容   | 不兼容 |
| **意向排他锁（IX）** | 兼容             | 兼容             | 不兼容 | 不兼容 |
| **S**                | 兼容             | 不兼容           | 兼容   | 不兼容 |
| **X**                | 不兼容           | 不兼容           | 不兼容 | 不兼容 |

### 3.2 一致性非锁定读

是InnoDB存储引擎通过行**多版本控制**的方式**读取**当前执行时间数据库中**行数据**。

如果读取的行正在执行行的**DELETE**或**UPDATE**操作，这是读取操作**不会因此去等待行上锁（X）的释放**。相反的，引擎会去读取行的一个快照数据。

快照是指改行的之前版本的数据，通过undo段完成的，undo用来事务中回滚数据，因此快照数据是没有额外开销的。

读取快照是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。

非锁定读机制提高了数据库的并发性。

不是所有的事务隔离级别下都是采用非锁定的一致性读的。

**读已提交**和**可重复读**（默认）下，使用的是**非锁定的一致性读**的，然而对快照数据的定义却不相同，

**读已提交**：非一致性读总是读取被锁定行的最新一份快照数据

可重复读：对于快照，非一致性读总是读取事务开始时的行数据版本。

### 3.3 一致性锁定读

可重复读模式下，SELECT操作使用一致性非锁定读。某些情况下，用户需要显示地对数据库读取操作进行加锁操作以保证数据逻辑一致性。

InnoDB存储引擎对于SELECT语句保持两种一致性的锁定读操作：

- SELECT...FOR UPDATE
- SELECT...LOCK IN SHARE MODE 

1）对读取的行记录一个X锁，其他事物不能对已锁定的行加任何锁

2）对读取的行记录加S锁，其他事物可以向被锁定的行加S锁，但是如果加X锁就会被阻塞

