---
title: Volatile关键字
date: '2017/8/01 10:56:41'
copyright: true
categories:
  - NoteBook
tags:
  - JAVA
  - 基础
  - 多线程
abbrlink: 3fbd301a
top: 1
---
![volatile](vol.jpg)

**Volatile 能够保证可见性。**

>  volatile的两大特性：禁止重排序、内存可见性。

    1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。
    2）禁止进行指令重排序。

<!-- more -->
并发编程中三大概念：**原子性，有序性，可见性。**

---

### 1.原子性
一个操作或者多个操作，要么全部执行并且执行过程中不会被任何一个因素打扰，要么就不会执行。
Java中，对于基本数据类型的变量读取和赋值操作是原子的。

```
x=10;   //1
y=x;    //2
x++;    //3
x=x+1;  //4

```
只有1是原子的操作。

2是两个操作，先读取x的值，在把x的值写入工作内存，这两个操作都是原子操作，放在一起就不是原子操作了。

3和4都是先读取x的值，在进行加一的操作，写入新的值。

只有简单的读取、赋值（变量之间赋值不是）才是原子操作。

可以通过synchronized和Lock解决原子性问题。

### 2.可见性
线程之间的可见性，一个线程修改共享变量的值，其他的线程能够得知这个修改。

Java中，volatile关键字来保证可见性。
被volatile修饰的变量，变量修改的值会立即更新到主内存，每次使用前立即从主内存刷新，当其他线程需要读取的时候。就会读取主存的值。

普通变量被修改的时候，什么时候写入主存是不确定的。当其他线程读取的时候可能还是原来的值，因此无法保证可见性。

synchronized和final能实现可见性

​	同步块：对一个变量执行unLock之前，必须把此变量同步回主内存中。

​	final：被final修饰的字段在构造器中一旦初始化完成， 并且构造器没有把“this”引用传递出去，其他线程就能看见这个final字段的值。

### 3.有序性
程序执行的顺序按照代码先后执行。

指令重排序不会影响单个线程的执行，会影响到线程并发执行的正确性。

Java中允许编译器和处理器对指令进行重排序，volatile、和synchronized都可以保证有序性，

### 应用场景
1.状态标记量
2.double check
---
volatile实现原理

happen-before （先行发生原则）：判断数据是否存在竞争，线程是否安全的主要依据。

如果操作A先行发生于B，发生操作B之前，操作A产生的影响能被B观察到。

插入内存屏障：如果一个操作的执行结果对另一个操作可见，那么这两个操作之间必须要存在内存屏障(写之前StoreStore ，写之后StoreLoad)

volatile读操作性能消耗和普通变量几乎没差别，写操作可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令保证处理器不会发生乱序执行。

大多数场景下volatile总开销要比锁低。

























